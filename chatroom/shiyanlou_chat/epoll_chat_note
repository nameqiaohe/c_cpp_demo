============ epoll 实现聊天室 ============
1、环境
	Linux ( Ubuntu15.04 )

2、介绍
	(1) 一个简单的聊天室：服务端 + 客户端

	(2) 不涉及以下部分
		线程池、多线程编程、超时重传、确认收包

	(3) 主要用于了解 C/S 模型，以及 epoll的使用

3、服务端
	(1) 支持多个用户接入，实现 聊天的基本功能

	(2) 使用 epoll 机制实现 并发，增加效率

4、客户端
	(1) 支持用户输入聊天信息
	(2) 显示其他用户发来的消息
	(3) 使用 fork创建两个进程
		子进程的功能：
			等待用户输入聊天信息
			将聊天信息写入 pipe，并发给父进程

		父进程的功能：
			使用 epoll机制接收 Server发来的消息，并显示给用户
			将子进程发来的消息从 pipe中读出，并发给Server

5、代码文件说明
	3个文件：
		server.cpp 服务端
		client.cpp 客户端
		utility.h 包含server 和 client斗湖用到的一些头文件、变量声明、函数、宏
		
		server、client共同的头文件：
			<sys/types.h>
			<sys/wait.h>
			<sys/socket.h>
			<arpa/inet.h>
			<sys/epoll.h>
			<fcntl.h>
			<errno.h>
			<stdio.h>
			<stdlib.h>
			<string.h>
			<time.h>

6、C/S模型
	简单介绍一下 服务端、客户端采用的经典C/S模型，以及 TCP/IP

	参考 C-S模型.png

	TCP 服务端通信常规步骤：
		Step 1：使用 socket() 创建 TCP 套接字 listenfd
		Step 2：将创建的套接字 绑定到一个本地IP 和 端口上	bind()
		Step 3：监听端口上的连接请求	listen()
		Step 4：当请求到来时，接受连接请求，返回一个对应于此次连接的新的套接字	accept()
		Step 5：用 accept() 返回的套接字 和 客户端进行通信
			使用 write()/send()、recv()/read()
		Step 6：返回，等待另一个连接请求
		Step 7：通信结束，关闭套接字	close()

	TCP 客户端通信的常规步骤：
		Step 1：创建套接字	socket()
		Step 2：使用 connect() 向服务端发起连接请求
		Step 3：连接成功，进行通信
			使用 write()/send()、recv()/read()
		Step 4：通信结束，关闭套接字	close()
	
7、阻塞、非阻塞socket
	通常，一个文件描述符指定的文件/设备，有两种工作方式：阻塞、非阻塞。
	
	阻塞：当试图对该文件描述符进行读写时，若当前没有数据可读、或暂时不可写，程序就进入等待，直到有东西可读 或 可写为止。

	非阻塞：如果没有数据可读、或者不可写，读写函数马上返回，而不会等待。

	阻塞 与 非阻塞的区别：是否立即返回

	将文件描述符设置为非阻塞方式：
		int setnonblocking(int fd){
			int retValue = fcntl(fd, F_SETFL, fcntl(fd, F_GETFD, 0) | O_NONBLOCK);
			if(retValue != -1){
				return 0;
			}else{
				return -1;
			}
		}
